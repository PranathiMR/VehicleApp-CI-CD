name: Module - Docker & Integration

on:
  workflow_call:
    inputs:
      # The full image tag to build/push
      image_uri:
        required: true
        type: string
      # Safety level (high/low) to control Trivy severity
      criticality:
        required: true
        type: string
      # Name of the binary artifact from the Build Module
      artifact_name:
        required: true
        type: string
      # Directory containing Dockerfile and compose files
      context_path:
        required: false
        type: string
        default: "."
      # Location of the binary for Docker access
      binary_dest_path:
        required: false
        type: string
        default: "bin" 
    secrets:
      registry_token:
        required: true

jobs:
  # Job A: Build & Scan
  docker-build:
    name: Docker Build & Scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { submodules: recursive }

      # Download the specific artifact
      - uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}
          # Place binary where Dockerfile expects it (relative to context)
          path: ${{ inputs.context_path }}/${{ inputs.binary_dest_path }}

      # Clean Docker Build
      - name: Build Test Image (Clean)
        # Build inside the context path
        run: docker build --no-cache -t app:test ${{ inputs.context_path }}

      # Conditional Trivy Scan
      - name: Run Trivy Scan
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: 'app:test'
          format: 'table'
          output: 'trivy-results.txt'
          exit-code: 1
          severity: ${{ inputs.criticality == 'high' && 'MEDIUM,HIGH,CRITICAL' || 'HIGH,CRITICAL' }}

      # Upload Security Report
      - name: Upload Security Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results
          path: trivy-results.txt

  # Job B: Integration Tests
  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: docker-build
    steps:
      - uses: actions/checkout@v4
        with: { submodules: recursive }

      # Download binary again for the integration test context
      - uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}
          path: ${{ inputs.context_path }}/${{ inputs.binary_dest_path }}

      - name: Run Integration Tests
        working-directory: ${{ inputs.context_path }}
        run: |
          echo "listener 1883" > mosquitto.conf
          echo "allow_anonymous true" >> mosquitto.conf
          
          # We use the abstract context path implicitly by setting working-directory above
          docker compose -f docker-compose.yml -f docker-compose.ci.yml up --build --exit-code-from integration-test-runner

      # Upload Logs
      - name: Dump Logs
        if: always()
        working-directory: ${{ inputs.context_path }}
        run: docker compose logs > full_test_logs.txt

      - name: Upload Logs Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-logs
          path: ${{ inputs.context_path }}/full_test_logs.txt

      # Auto-Teardown (Guaranteed by 'if: always()')
      - name: Teardown Environment
        if: always()
        working-directory: ${{ inputs.context_path }}
        run: docker compose down -v

  # Job C: Publish
  publish-image:
    name: Publish to Registry
    runs-on: ubuntu-latest
    needs: integration-test
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
        with: { submodules: recursive }

      # Download binary for the final build
      - uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}
          path: ${{ inputs.context_path }}/${{ inputs.binary_dest_path }}
      
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.registry_token }}

      # Verify Unique Tag
      - name: Verify Tag Uniqueness
        run: |
          if docker manifest inspect ${{ inputs.image_uri }} > /dev/null 2>&1; then
            echo "Error: Tag ${{ inputs.image_uri }} already exists in registry!"
            echo "We do not overwrite existing tags for safety."
            exit 1
          else
            echo "Tag is unique. Proceeding."
          fi

      - name: Build and Push
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.context_path }}
          push: true
          # Clean Build for Production too
          no-cache: true
          tags: ${{ inputs.image_uri }}